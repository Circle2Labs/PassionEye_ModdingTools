#ifndef UTILS_HLSL
#define UTILS_HLSL

#include "ColorSpaces.hlsl"

#ifndef SHADERGRAPH_PREVIEW
    //#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Texture.hlsl"
    #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl"
    #include "Packages/com.unity.shadergraph/ShaderGraphLibrary/Functions.hlsl"
#endif

/**
 * \brief Inverses a linear interpolation
 * \param from lower bounds of the lerp
 * \param to upper bounds of the lerp
 * \param value Input value
 * \return Amount to mix from and to to generate value.
 */
float invLerp(float from, float to, float value) {
    return (value - from) / (to - from);
}

/**
 * \brief Maps a value from one range to another.
 * \param fromMin Start of the input range.
 * \param fromMax End of the input range.
 * \param toMin Start of the output range.
 * \param toMax End of the output range.
 * \param value Value in inout range to map into output range.
 * \return value remapped into output range.
 */
float remap(float fromMin, float fromMax, float toMin, float toMax, float value) {
    float rel = invLerp(fromMin, fromMax, value);
    return lerp(toMin, toMax, rel);
}

/**
 * \brief Samples ShadowCoords from a position in world space.
 * \param PosWS Position in world space.
 * \return ShadowCoords at PosWS.
 */
float4 SampleShadowCoord(float3 PosWS) {
    #ifndef SHADERGRAPH_PREVIEW
        #if _MAIN_LIGHT_SHADOWS_SCREEN
            //if we are using screen space shadows, we need to compute the screen position
            return ComputeScreenPos(TransformWorldToHClip(PosWS));
        #else
            //otherwise we can just use the world position and classic lightmaps.
            return  TransformWorldToShadowCoord(PosWS);
        #endif
    #else
        //preview doesn't have shadows or GI
        return 0;
    #endif
}

/**
 * \brief Samples ShadowCoords from a position in world space.
 * \param PosWS Position in world space.
 * \return ShadowCoords at PosWS.
 */
half4 SampleShadowCoord(half3 PosWS) {
    #ifndef SHADERGRAPH_PREVIEW
        #if _MAIN_LIGHT_SHADOWS_SCREEN
            //if we are using screen space shadows, we need to compute the screen position
            return ComputeScreenPos(TransformWorldToHClip(PosWS));
        #else
            //otherwise we can just use the world position and classic lightmaps.
            return TransformWorldToShadowCoord(PosWS);
        #endif
    #else
        //preview doesn't have shadows or GI
        return 0;
    #endif
}

/**
 * \brief Calculates a shadowed color based on the shadow amount.
 * \param baseColor Input color.
 * \param shadowAmount Amount of shadow to apply.
 * \return Shadowed color.
 */
float4 AutoShadowColor(float3 baseColor, float shadowAmount) {
    float3 shadowcolorHSV = RGBAtoHSVA(float4(baseColor,1));
    if (shadowcolorHSV.x == 0) {
        shadowcolorHSV.z += shadowAmount;
    } else
    {
        shadowcolorHSV.y += shadowAmount;
        shadowcolorHSV.z += shadowAmount;
        shadowcolorHSV = saturate(shadowcolorHSV);
    }
    return HSVAtoRGBA(float4(shadowcolorHSV,1));
}

/**
 * \brief Calculates a specular color based on the underlying texture color
 * \param baseColor Input color.
 * \return Specular color.
 */
float4 AutoSpecularColor(float3 baseColor) {
    float3 specularColorHSV = RGBAtoHSVA(float4(baseColor,1));
    specularColorHSV.z += 0.7;
    specularColorHSV = saturate(specularColorHSV);
    return HSVAtoRGBA(float4(specularColorHSV,1));
}

/**
 * \brief Blends2 normals vector together.
 * \param a first normal vector.
 * \param b second normal vector.
 * \return blended normal vector.
 */
float3 NormalBlend(float3 a, float3 b) {
    return normalize(float3(a.rg + b.rg, a.b * b.b));
}

/**
 * \brief This function is a copy of the AutoGenerated code from the unity Gradient Sample node.
 * \param Gradient to sample from.
 * \param Time point to sample the gradient at.
 * \return Sampled color at time point.
 */
float4 UnitySampleGradient(Gradient Gradient, float Time) {
    float3 color = Gradient.colors[0].rgb;
    [unroll]
    for (int c = 1; c < 8; c++)
    {
        float colorPos = saturate((Time - Gradient.colors[c-1].w) / (Gradient.colors[c].w - Gradient.colors[c-1].w)) * step(c, Gradient.colorsLength-1);
        color = lerp(color, Gradient.colors[c].rgb, lerp(colorPos, step(0.01, colorPos), .5));
    }
    #ifndef UNITY_COLORSPACE_GAMMA
    color = SRGBToLinear(color);
    #endif
    return float4(color, 1.0);
}

/**
 * \brief computes a fresnel term.
 * \param normalWS normal vector in world space.
 * \param ViewDirWS view direction in world space.
 * \param power fresnel term power. (0-1)
 * \param intensity intensity of the fresnel term. (0-1)
 * \return computed fresnel term.
 */
float Fresnel(float3 normalWS, float3 ViewDirWS, float power, float intensity) {
    float NdotV = dot(normalize(normalWS), normalize(ViewDirWS));
    return saturate(pow(1.0 - NdotV, power*10) * intensity);
}

/**
 * \brief computes a fresnel term.
 * \param normalWS normal vector in world space.
 * \param ViewDirWS view direction in world space.
 * \param power fresnel term power. (0-1)
 * \param intensity intensity of the fresnel term. (0-1)
 * \return computed fresnel term.
 */
half Fresnel(half3 normalWS, half3 ViewDirWS, half power, half intensity) {
    half NdotV = dot(normalize(normalWS), normalize(ViewDirWS));
    return saturate(pow(1.0 - NdotV, power*10) * intensity);
}

float LinearToPerceivedLightness(float3 color)
{
    return color.r * 0.2126 + color.g * 0.7152 + color.b * 0.0722;
}

#endif