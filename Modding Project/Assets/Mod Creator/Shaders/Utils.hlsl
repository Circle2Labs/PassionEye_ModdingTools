#ifndef UTILS_HLSL
#define UTILS_HLSL

#include "ColorSpaces.hlsl"

#ifndef SHADERGRAPH_PREVIEW
    //#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Texture.hlsl"
    #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl"
    #include "Packages/com.unity.shadergraph/ShaderGraphLibrary/Functions.hlsl"
#endif

#define INFLATE(x, vert, norm) vert += norm * x
#define PI 3.14159265359
#define CBufTexture(x) Texture2D x; SamplerState sampler##x; float4 x##_ST

#define ret3(x) return float4(x,1)

/**
 * \brief Inverses a linear interpolation
 * \param from lower bounds of the lerp
 * \param to upper bounds of the lerp
 * \param value Input value
 * \return Amount to mix from and to to generate value.
 */
float invLerp(float from, float to, float value) {
    return (value - from) / (to - from);
}

float3 invLerp(float3 from, float3 to, float3 value) {
    return (value - from) / (to - from);
}

/**
 * \brief Maps a value from one range to another.
 * \param fromMin Start of the input range.
 * \param fromMax End of the input range.
 * \param toMin Start of the output range.
 * \param toMax End of the output range.
 * \param value Value in inout range to map into output range.
 * \return value remapped into output range.
 */
float remap(float fromMin, float fromMax, float toMin, float toMax, float value) {
    float rel = invLerp(fromMin, fromMax, value);
    return lerp(toMin, toMax, rel);
}


float3 remap(float3 fromMin, float3 fromMax, float3 toMin, float3 toMax, float3 value) {
    float rel = invLerp(fromMin, fromMax, value);
    return lerp(toMin, toMax, rel);
}

/**
 * \brief Samples ShadowCoords from a position in world space.
 * \param PosWS Position in world space.
 * \return ShadowCoords at PosWS.
 */
float4 SampleShadowCoord(float3 PosWS) {
    #ifdef SHADERGRAPH_PREVIEW
        //preview doesn't have shadows or GI
        return 0;
    #endif
    
    #if _MAIN_LIGHT_SHADOWS_SCREEN
        //if we are using screen space shadows, we need to compute the screen position
        return ComputeScreenPos(TransformWorldToHClip(PosWS));
    #else
        //otherwise we can just use the world position and classic lightmaps.
        return  TransformWorldToShadowCoord(PosWS);
    #endif
}

/**
 * \brief Samples ShadowCoords from a position in world space.
 * \param PosWS Position in world space.
 * \return ShadowCoords at PosWS.
 */
half4 SampleShadowCoord(half3 PosWS) {
    #ifndef SHADERGRAPH_PREVIEW
        #if _MAIN_LIGHT_SHADOWS_SCREEN
            //if we are using screen space shadows, we need to compute the screen position
            return ComputeScreenPos(TransformWorldToHClip(PosWS));
        #else
            //otherwise we can just use the world position and classic lightmaps.
            return TransformWorldToShadowCoord(PosWS);
        #endif
    #else
        //preview doesn't have shadows or GI
        return 0;
    #endif
}

/**
 * \brief Calculates a shadowed color based on the shadow amount.
 * \param baseColor Input color.
 * \param shadowAmount Amount of shadow to apply.
 * \return Shadowed color.
 */
float3 AutoShadowColor(float3 baseColor, float shadowAmount) {
    float3 shadowcolorHSV = RGBtoHSV(baseColor);
    if (shadowcolorHSV.x == 0) {
        shadowcolorHSV.z += shadowAmount;
    } else
    {
        shadowcolorHSV.y += shadowAmount;
        shadowcolorHSV.z += shadowAmount;
        shadowcolorHSV = saturate(shadowcolorHSV);
    }
    return HSVtoRGB(shadowcolorHSV);
}

/**
 * \brief Calculates a specular color based on the underlying texture color
 * \param baseColor Input color.
 * \return Specular color.
 */
float3 AutoSpecularColor(float3 baseColor) {
    float3 specularColorHSV = RGBtoHSV(baseColor);
    specularColorHSV.z += 0.7;
    specularColorHSV = saturate(specularColorHSV);
    return HSVtoRGB(specularColorHSV);
}

/**
 * \brief Blends2 normals vector together.
 * \param a first normal vector.
 * \param b second normal vector.
 * \return blended normal vector.
 */
float3 NormalBlend(float3 a, float3 b) {
    return normalize(float3(a.rg + b.rg, a.b * b.b));
}

/**
 * \brief This function is a copy of the AutoGenerated code from the unity Gradient Sample node.
 * \param Gradient to sample from.
 * \param Time point to sample the gradient at.
 * \return Sampled color at time point.
 */
float4 UnitySampleGradient(Gradient Gradient, float Time) {
    float3 color = Gradient.colors[0].rgb;
    [unroll]
    for (int c = 1; c < 8; c++)
    {
        float colorPos = saturate((Time - Gradient.colors[c-1].w) / clamp(Gradient.colors[c].w - Gradient.colors[c-1].w, FLT_EPS, FLT_INF)) * step(c, Gradient.colorsLength-1);
        color = lerp(color, Gradient.colors[c].rgb, lerp(colorPos, step(0.01, colorPos), .5));
    }
    #ifndef UNITY_COLORSPACE_GAMMA
    color = SRGBToLinear(color);
    #endif
    return float4(color, 1.0);
}

/**
 * \brief computes a fresnel term.
 * \param normalWS normal vector in world space.
 * \param ViewDirWS view direction in world space.
 * \param power fresnel term power. (0-1)
 * \param intensity intensity of the fresnel term. (0-1)
 * \return computed fresnel term.
 */
float Fresnel(float3 normalWS, float3 ViewDirWS, float power, float intensity) {
    float NdotV = dot(normalize(normalWS), normalize(ViewDirWS));
    return saturate(pow(abs(1.0 - NdotV), power*10) * intensity);
}

/**
 * \brief computes a fresnel term.
 * \param normalWS normal vector in world space.
 * \param ViewDirWS view direction in world space.
 * \param power fresnel term power. (0-1)
 * \param intensity intensity of the fresnel term. (0-1)
 * \return computed fresnel term.
 */
half Fresnel(half3 normalWS, half3 ViewDirWS, half power, half intensity) {
    half NdotV = dot(normalize(normalWS), normalize(ViewDirWS));
    return saturate(pow(1.0 - NdotV, power*10) * intensity);
}

/**
 * \brief Converts a linear RGB color to perceived lightness.
 * \param color Input color in linear RGB space.
 * \return Perceived lightness of the color.
 */
float LinearToPerceivedLightness(float3 color)
{
    return color.r * 0.2126 + color.g * 0.7152 + color.b * 0.0722;
}

/**
* \brief Converts a normal vector from tangent space to world space.
* \param normalTS Texture normal vector in tangent space.
* \param normalWS Mesh normal vector in world space.
* \param tangentWS Mesh tangent vector in world space.
* \return Normal vector in world space.
*/
float3 NormalMapToWorld(float3 normalTS, float3 normalWS, float4 tangentWS) {
    float sign = tangentWS.w;
    float3 bitangentWS = cross(normalWS, tangentWS.xyz) * sign;
                
    return TransformTangentToWorld(normalTS, half3x3(tangentWS.xyz, bitangentWS.xyz, normalWS.xyz));
}

/**
 * \brief Generates a pseudo-random number based on the input coordinates.
 * \param uv Input coordinates.
 * \return Pseudo-random number.
 */
float nrand(float2 uv)
{
    return frac(sin(dot(uv, float2(12.9898, 78.233))) * 43758.5453);
}

/**
 * \brief Deforms the UV coordinates based on the given deformation scale.
 * \param uv Input UV coordinates.
 * \param deform Deformation scale.
 * \return Deformed UV coordinates.
 */
float2 deformScaleUV(float2 uv, float2 deform)
{
    float2 deformFrac = 1.0 / deform;
    return (uv * deformFrac) + ((1 - deformFrac) / 2.0);
}

/**
 * \brief Calculates the RGB color of a given kelvin temperature.
 * \param kelvin Temperature in kelvin.
 * \return RGB color of the temperature.
 */
float3 kelvinToRGB(float kelvin)
{
    float temp = kelvin / 100;
    float red, green, blue;

    if (temp <= 66)
    {
        red = 255;
    } else {
        red = temp - 60;
        red = 329.698727446 * pow(red, -0.1332047592);
        if (red < 0) red = 0;
        if (red > 255) red = 255;
    }

    if (temp <= 66)
    {
        green = temp;
        green = 99.4708025861 * log(green) - 161.1195681661;
        if (green < 0) green = 0;
        if (green > 255) green = 255;
    } else {
        green = temp - 60;
        green = 288.1221695283 * pow(green, -0.0755148492);
        if (green < 0) green = 0;
        if (green > 255) green = 255;
    }

    if (temp >= 66)
    {
        blue = 255;
    } else if (temp <= 19) {
        blue = 0;
    } else {
        blue = temp - 10;
        blue = 138.5177312231 * log(blue) - 305.0447927307;
        if (blue < 0) blue = 0;
        if (blue > 255) blue = 255;
    }

    return float3(red / 255, green / 255, blue / 255);
}

/**
 * \brief Converts a time coefficient (hour) to a kelvin temperature.
 * \param coeff Time coefficient.
 * \return Kelvin temperature.
 */
float TimeCoefficientToKelvin(float coeff){ //0-1 -> 0:00-24:00
    // minimum at 2:00, maximum at 14:00
    // shift coefficient so 0 = 2:00
    coeff = (coeff + (2.0 / 24.0)) % 1.0;
    if (coeff < 0.5) {
        return lerp(2000, 6500, coeff * 2);
    } else {
        return lerp(6500, 2000, (coeff - 0.5) * 2);
    }
}

float smoothClamp(float x, float a, float b)
{
    return smoothstep(0., 1., (x - a)/(b - a))*(b - a) + a;
}

float softClamp(float x, float a, float b)
{
    return smoothstep(0., 1., (2./3.)*(x - a)/(b - a) + (1./6.))*(b - a) + a;
}

#endif